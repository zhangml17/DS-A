# DS&A
Data Structures & Algorithms with JavaScript
## 链表
### 单链表
插入或删除时需要从头查找要操作的元素的前一个节点
### 双向链表
节点有了前驱和后继，删除节点时不必再查找待删除节点的前驱节点了,删除效率比单链表的效率高
### 循环链表
初始化时头节点的next属性指向其本身，链表的尾节点指向头结点即可(注意循环链表的while判断终止条件)
## 二叉树
子节点个数不超过2个的特殊的树
### 二叉查找树BST
一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中
#### 遍历
##### 深度遍历
其遍历的顺序可以理解为相对于根节点的先、中、后
+ 先序遍历(根 --> 左 --> 右)
+ 中序遍历(左 --> 根 --> 右)
+ 后序遍历(左 --> 右 --> 根)
##### 广度遍历
广度遍历也叫层次遍历，需要其他数据结构的支持
#### 查找
+ 最小值。遍历左子树，直到找到最后一个节点
+ 最大值。遍历右子树，直到找到最后一个节点
+ 查找给定值。与当前节点的值比较，决定向左子树遍历还是右子树遍历
## 集合
+ 集合中成员无序
+ 集合中成员不重复
## 栈(LIFO)
栈是一种高效的数据结构，因为数据只能在栈顶添加或删除
高级：[最小栈](https://leetcode-cn.com/problems/min-stack/)
### 栈的应用
+ 数制间的转换
+ 回文序列的判断
+ 实现递归
## 列表
适用于数据元素不太多，或不用再很长的列表中查找元素或排序时
## 队列(FIFO)
队列是一种列表，不同的是队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据。
高级：[循环队列](https://leetcode-cn.com/problems/design-circular-queue/)
假溢出：在顺序队列中，当队尾指针已经到数组的上界，不能再执行入队操作，但其实队列中还有空位置，这就叫做**假溢出**
### 循环队列(解决假溢出的方式)
```
front: 队首指针；rear：队尾指针；N：队列的最大长度；
队空：front === rear
队满: front === (rear + 1) % N
队列长度：L = (N + rear - front) % N
```
## 散列
在散列表(也叫哈希表)上插入、删除和取用数据都非常快，但是对于查找操作效率却很低下 
使用散列表存储数据时，通过一个**散列函数**将键映射为一个数字，这个数字的范围是0到散列表的长度
即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象叫**碰撞**
### 如何尽可能避免碰撞
首先要确保散列表中用来存储数据的数组大小是个**质数**
其次，数组的长度应该在100以上，这是为了让数据在散列中分布的更加均匀
还要有一个计算散列值的好方法(**霍纳算法**：散列函数仍然是计算字符串中各个字符的ASCII码值，不过求和时每次要乘以一个质数)
### 解决碰撞
#### 开链法
#### 线性探测法